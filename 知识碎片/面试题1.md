# 面试题（一）

### 1、曾经做过的应该影响最深的项目

&#x9;回答这个问题需要注意一下几个点

*   &#x9;**1、突出挑战**

    &#x9;可以从技术、时间、团队协作等多个角度描述挑战，展示你的综合能力

*   \*\*	2、强调解决方案\*\*：

    &#x20;   如何应对挑战，采用的技术和方法，突出你解决问题的能力和思路

*   &#x20;  **3、体现成果：**

    &#x20;   体现成果，比如用户反馈，性能指数等等

*   &#x20;  **4、表达成长：**

    &#x20;  通过这个项目你学到了什么，有什么收获和成长；体现你学习能力和自我提升的意识

###### &#x9;举例：

&#x9;	**一、项目背景**

*   \*\*明确目标：\*\*你想要用这个技术解决什么问题？它能带来哪些价值？
*   \*\*现有条件：\*\*以现有的资源和技术基础能否满足新技术的要求？
*   \*\*成熟度：\*\*是否足够成熟，有丰富的生态和稳定的社区？
*   \*\*成本：\*\*开发成本、学习成本、维护成本？
*   \*\*兼容性：\*\*是否兼容现有系统，能否和其他技术整合
*   \*\*性能表现	\*\*

&#x9;		之前做的PhotoGrid图片编辑项目，项目中大量的使用了svg（矢量图）来实现图像的绘制编辑。

&#x9;   **二、遇到的问题**

&#x9;	1、性能优化难题

&#x9;			svg文件通常较大，加载大量图片文件的时候会出现加载缓慢影响用户体验，用户交互方面也会有卡顿现象。&#x9;

&#x9;	2、复杂图形绘制挑战

&#x9;			比如不规则多边形，曲线，这些需要需要精确的计算和路径定义。

&#x9;	3、用户交互设计难

&#x9;			如何设计简洁直观的用户界面，让用户能够轻松地进行图形编辑操作，如拖拽、缩放、旋转等，同时避免误操作，是一个很大的挑战。

&#x9;   **三、解决方案**

&#x9;	1、性能优化：使用**懒加载**方案减少初次绘制个数； **使用缓存**对经常使用的图形进行存储

&#x9;	2、复杂图形绘制：开发自定义的图形绘制工具和算法，通过数学计算和坐标转换，精确地绘制各种复杂图形。同时，提供图形编辑的辅助工具，如对齐工具、分布工具等，方便用户进行精确的图形布局。

&#x9;	3、调研和测试用户使用习惯，并给出相应操作的操作提示，让用户可以快速上手，必要的操作增加二次确认。

&#x9;  **四、成果**

&#x9;	最终也是成功的开发出了这款强大且性能稳定的在线图片编辑工具，满足了用户需求。并且持续为公司带来良好的收益和名声。

&#x20;    **五、收获**

&#x9;	做这个项目是我对svg有了更深的掌握，也提升了在性能优化方面的能力。在项目中遇到的各种复杂问题，通过不断的尝试和探索让我学会了如何分析和解决问题。当然与团队的协作更加的密切了，沟通也越来越高效，通过这个项目让我更加重视了用户的体验和解决用户的痛点是有多重要。

### 2、DOM的事件机制，怎么阻止事件捕获？

&#x9;DOM事件机制的流程：

&#x9;	1、\*\*事件捕获阶段：\*\*当一个事件发生时，浏览器会从 DOM 树的根节点开始向下传播事件，直到到达目标元素。

&#x9;	2、**目标阶段**: 当事件到达目标元素时，浏览器会触发目标元素上的事件处理程序。

&#x9;	3、**事件冒泡阶段**: 事件在目标元素上处理完毕后，会沿着 DOM 树向上冒泡，直到回到根节点。

&#x9;阻止事件捕获/事件冒泡： 通过event.stopPropagation()

### 3、常用的es6有哪些？var如何实现let

&#x9;常用的es6:

&#x9;	let/const、解构赋值、Promise、箭头函数、模版字符串、...展开符、class等

&#x9;var、let、const区别：\
&#x9;	var可以重复声明相同的变量；var会声明提升；var不支持块级作用域（function中可以）；const不可以修改值（数组、对象可以）

&#x9;var实现let：

```javascript
	(function(){
		var aa = 'var实现let'
	})()
```

### 4、\$nextTick实现

&#x9;支持Promise的浏览器是用**Promise**.resolve().then()；如果支持MutationObserver则使用**MutationObserver**；ie使用**setImmediate; setTimeout**兜底

### 5、rem和em的区别

&#x9;**`em`:** 基准值是其父元素的字体大小，会随着其父元素字体大小改变而改变。容易造成字体大小混乱，尤其是在嵌套元素较多时。\*\*	\*\*

\*\*	`rem`:\*\* 基准值是根元素（`<html>` 元素）的字体大小，适合用于响应式设计。

### 6、解决跨域的方式

&#x9;**1. 后端设置 CORS (Cross-Origin Resource Sharing)**

&#x9;	需要在响应头中增加 **Access-Control-Allow-Origin**   &#x20;

&#x9;	Access-Control-Allow-Origin: \* 代表所有域名都可以访问

&#x9;	Access-Control-Allow-Origin: <http://example.com> 代表指定域名可以访问

&#x9;**2. 使用代理服务器**

&#x9;	前端项目中配置代理服务

&#x9;	例如webpack.config.js中配置

```javascript
module.exports = {
  devServer: {
    proxy: {
      '/api': {
        target: 'http://example.com',
        changeOrigin: true,
        pathRewrite: { '^/api': '' }
      }
    }
  }
};			
```

&#x9;**3. 使用 JSONP (JSON with Padding)**

&#x9;	jsonp是利用了**script标签具有跨域的功能**，通过script加载目标服务的脚步，脚本中包含回调函数，目标服务器将数据作为回调函数的参数传递回来。这种方式只能使用get方式，且安全性低

\*\*	4. 使用 WebSocket\*\*

&#x9;	WebSocket 是一种\*\*双向通信协议，\*\*连接建立后，就可以进行双向通信，不受同源策略限制

### 7、使用setTimeout实现setInterval

```javascript
	function mySetInterval(callback, delay){
		function run () {
			callback();
			setTimeout(run, delay)
		}
		setTimeout(run, delay)
	}
	// 使用方式	
	mySetInterval(()=>{
		console.log('111111')	
	},1000)
```

### 8、vue双向绑定的机制

&#x9;	vue双向绑定机制的\*\*核心是v-model; \*\*

&#x9;	vue双向绑定的实现原理是通过：**数据劫持**和**发布订阅模式**实现的。

&#x9;		**·** **数据劫持**：vue2通过**Object.defineProperty**，vue3是通过**Proxy**方法进行数据劫持和监听数据变化；

&#x9;		**·** **发布订阅者**：当数据变化的时候，vue会通知所有订阅了该数据的组件进行视图更新。

### 9、node有哪些性能问题

&#x9;	其实与js相仿

&#x9;	**1. 事件循环阻塞**

&#x9;		node是单线程事件循环模型，如果某个事件执行事件过长就会影响事件循环中的其他任务，比如：同步执行文件I/O，数据库操作，阻塞的网络请求，便利大型数组等。

&#x9;	**2. 内存泄漏**

&#x9;		不规范的使用闭包，在循环中全局变量的使用，时间监听却不移除监听，导致的内存一直被占用，无法被回收。。

&#x9;	**解决方案：**

*   使用异步操作，避免阻塞事件循环。
*   优化代码，减少循环嵌套、避免频繁创建对象。
*   使用性能分析工具，找出性能瓶颈。			&#x9;

### 10、node做耗时计算时如何避免阻塞

\*\*		1. 使用异步操作：\*\*

&#x9;		node提供了异步操作的api。比如fs.readFile，http.get等；

&#x9;	**2. 使用 Worker Threads：**

&#x9;		创建独立的线程，从而避免阻塞主线程。

```javascript
// 使用异步操作
const fs = require('fs');

fs.readFile('large_file.txt', 'utf8', (err, data) => {
  if (err) {
    console.error(err);
  } else {
    // 处理文件内容
    console.log(data);
  }
});

// 使用 Worker Threads
const { Worker } = require('worker_threads');

const worker = new Worker('./worker.js', {
  workerData: {
    // 传递数据给 Worker 线程
  }
});

worker.on('message', (message) => {
  // 处理 Worker 线程返回的结果
  console.log(message);
});

worker.on('error', (error) => {
  console.error(error);
});

// Worker 线程代码
// worker.js
const { workerData, parentPort } = require('worker_threads');

// 进行耗时计算
const result = calculateSomething(workerData);

// 将结果返回给主线程
parentPort.postMessage(result);
```

\*\*	3. 使用第三方库：\*\*

&#x9;	例如 `async`、`bluebird` 等，提供了更方便的异步操作方法，可以帮助你更轻松地编写异步代码

### 11、未来的职业规划

&#x9;	**技术方面**：一直会在一些大佬的博客中索取新的前端动态和知识，计划更加深入的学习vue及react，对性能优化和前端安全方面正对性的学习加强。

&#x9;	**团队方面**：积累更多的项目经验，并且学习团队管理的经验，希望未来可以胜任前端组长职位，能够带领团队完成复杂的项目，具有挑战性的项目。

&#x9;	**领域方面**：希望能把前端和其他领域相结合，例如：人工智能，数据可视化等场景。

.

.

.

.

.

.

.

.

.

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_end\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
