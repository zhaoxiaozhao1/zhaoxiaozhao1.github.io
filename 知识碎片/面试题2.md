# 面试题（二）

### **1、大文件的分片上传和断点续传**

#### \*\*	1. 分片上传\*\*

&#x9;	分片上传将大文件分割成多个小文件（片段），然后分别上传到服务器。这样可以有效降低单个文件上传的压力，提高上传效率，并方便断点续传。

\*\*		实现步骤：\*\*

1.  **计算分片大小：** 根据网络状况和服务器限制，确定每个分片的合适大小。
2.  **分割文件：** 使用 JavaScript 的 `Blob.slice()` 方法将大文件分割成多个片段。
3.  **上传分片：** 使用 AJAX 或 Fetch API 将每个分片上传到服务器。
4.  **服务器端处理：** 服务器端接收每个分片，并将其存储到临时目录。

#### &#x9;2. 断点续传

&#x9;	断点续传是指在上传过程中，如果出现网络中断或其他错误，可以从上次上传成功的位置继续上传，避免重新上传整个文件。

\*\*		实现步骤：\*\*

1.  **记录上传进度：** 在客户端使用 localStorage 或 IndexedDB 记录每个分片的上传进度，包括已上传的字节数和分片序号。
2.  **服务器端存储进度：** 服务器端也需要存储每个分片的上传进度，可以使用数据库或文件系统。
3.  **恢复上传：** 当用户重新上传文件时，客户端读取本地存储的进度信息，并从上次上传成功的位置开始上传。
4.  **服务器端校验：** 服务器端需要校验每个分片是否已经上传，并根据进度信息决定是否需要重新上传。

#### &#x9;3. 代码示例

```javascript
	// 分片上传函数
function uploadChunk(file, chunkIndex, chunkSize) {
  const start = chunkIndex * chunkSize;
  const end = Math.min(start + chunkSize, file.size);
  const chunk = file.slice(start, end);

  // 使用 AJAX 或 Fetch API 上传分片
  fetch('/upload', {
    method: 'POST',
    body: chunk,
    headers: {
      'Content-Type': 'application/octet-stream',
      'chunk-index': chunkIndex,
      'total-chunks': Math.ceil(file.size / chunkSize),
    },
  })
  .then(response => {
    // 处理上传结果
    // 更新本地存储的上传进度
  })
  .catch(error => {
    // 处理上传错误
    // 尝试重新上传该分片
  });
}

// 断点续传函数
function resumeUpload(file) {
  // 读取本地存储的上传进度
  const progress = JSON.parse(localStorage.getItem('uploadProgress'));

  // 从上次上传成功的位置开始上传
  for (let i = progress.lastChunkIndex + 1; i < progress.totalChunks; i++) {
    uploadChunk(file, i, progress.chunkSize);
  }
}

// 上传文件
function uploadFile(file) {
  // 计算分片大小
  const chunkSize = 1024 * 1024; // 1MB

  // 分割文件并上传
  for (let i = 0; i < Math.ceil(file.size / chunkSize); i++) {
    uploadChunk(file, i, chunkSize);
  }
}

// 监听文件选择事件
document.getElementById('fileInput').addEventListener('change', function() {
  const file = this.files[0];
  // 判断是否需要断点续传
  if (localStorage.getItem('uploadProgress')) {
    resumeUpload(file);
  } else {
    uploadFile(file);
  }
});
```

### **2、抖音和h5是如何通信的**

&#x9;可以通过抖音提供的jsSDK实现通信，其根本是对JSBridge进行了封装。

#### &#x9;js实现方式：

&#x9;	**1. URL Scheme:**	利用 URL Scheme 协议，通过特定的 URL 格式来触发 Native 代码的执行		&#x9;

\*\*			·\*\* H5 页面通过 `window.location.href` 或 `a` 标签的 `href` 属性发送一个特定的 URL Scheme 请求。

&#x9;		**·** Native 代码监听特定 URL Scheme 的请求，并解析 URL 中的参数，执行相应的操作。

&#x9;		**·** Native 代码可以通过回调 URL Scheme 将结果返回给 H5 页面。

&#x9;		**·** 优点：简单易用，兼容性好。

&#x9;		**·** 缺点：只能传递简单的参数，无法传递复杂的数据结构。

&#x9;	**2. Android** \*\*WebView 的 addJavascriptInterface 方法：\*\*通过 `addJavascriptInterface` 方法将 Native 对象暴露给 JavaScript，JavaScript 可以直接调用 Native 对象的方法。

&#x9;		JavaScript 可以通过 `window.对象名.方法名()` 来调用 Native 对象的方法

\*\*		3. JavaScriptCore (iOS): \*\*iOS 7 及以上版本提供了 JavaScriptCore 库，允许 JavaScript 代码直接调用 Objective-C 代码。

&#x9;		**·** Native 代码将 Objective-C 方法绑定到Webview的JavaScriptContext 对象上。

&#x9;		**·** JavaScript 代码可以通过 `window.方法名()` 来调用 Objective-C 方法。

&#x9;	**4.** **WebSockets:** 使用 WebSockets 建立持久连接，实现双向通信。

```javascript
// webSocket使用事例
const ws = new WebSocket('ws://example.com/ws');

ws.onopen = function(event) {
  console.log('WebSocket 连接已建立');
  ws.send('Hello, server!');
};

ws.onmessage = function(event) {
  console.log('收到服务器消息：', event.data);
};

ws.onerror = function(event) {
  console.log('WebSocket 连接错误：', event.message);
};

ws.onclose = function(event) {
  console.log('WebSocket 连接已关闭');
};
// 关闭连接
ws.close();
// 发送消息给服务端
ws.send('Hello, server!');
```

### **3、要使用一个新的技术，需要考虑哪些方**面

*   &#x9;\*\*明确目标：\*\*你想要用这个技术解决什么问题？它能带来哪些价值？
*   &#x20;  \*\*现有条件：\*\*以现有的资源和技术基础能否满足新技术的要求？
*   &#x20;  \*\*成熟度：\*\*是否足够成熟，有丰富的生态和稳定的社区？
*   &#x20;  \*\*成本：\*\*开发成本、学习成本、维护成本？
*   &#x20;  \*\*兼容性：\*\*是否兼容现有系统，能否和其他技术整合
*   &#x20;  **性能表现**

### **4、性能指数统计方式**

```javascript
// 获取 FCP
    new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntriesByName('first-contentful-paint')) {
        console.log('FCP:', entry.startTime);
      }
    }).observe({ type: 'paint', buffered: true });

    // 获取 LCP
    new PerformanceObserver((entryList) => {
      for (const entry of entryList.getEntries()) {
        console.log('LCP:', entry.startTime);
      }
    }).observe({ type: 'largest-contentful-paint', buffered: true });

	function analyzePerformance() {
      if (!window.performance) {
        console.log('当前浏览器不支持 Performance API');
        return;
      }

      const performance = window.performance;
      const timing = performance.timing;
      const navigation = performance.navigation;

      const metrics = {
        navigationStart: timing.navigationStart,
        unloadEventStart: timing.unloadEventStart,
        unloadEventEnd: timing.unloadEventEnd,
        redirectStart: timing.redirectStart,
        redirectEnd: timing.redirectEnd,
        fetchStart: timing.fetchStart,
        domainLookupStart: timing.domainLookupStart,
        domainLookupEnd: timing.domainLookupEnd,
        connectStart: timing.connectStart,
        connectEnd: timing.connectEnd,
        secureConnectionStart: timing.secureConnectionStart,
        requestStart: timing.requestStart,
        responseStart: timing.responseStart,
        responseEnd: timing.responseEnd,
        domLoading: timing.domLoading,
        domInteractive: timing.domInteractive,
        domContentLoadedEventStart: timing.domContentLoadedEventStart,
        domContentLoadedEventEnd: timing.domContentLoadedEventEnd,
        domComplete: timing.domComplete,
        loadEventStart: timing.loadEventStart,
        loadEventEnd: timing.loadEventEnd,
        type: navigation.type,
        redirectCount: navigation.redirectCount
      };

      console.log('页面性能指标:', metrics);

      // 计算各个阶段的时间
      const stages = {
        redirectTime: metrics.redirectEnd - metrics.redirectStart, 		//重定向时间 (redirectTime)：从重定向开始到重定向结束的时间。
        appCacheTime: metrics.domainLookupStart - metrics.fetchStart,	//应用缓存时间 (appCacheTime)：从开始检查应用缓存到 DNS 查询开始的时间。
        dnsTime: metrics.domainLookupEnd - metrics.domainLookupStart,	//DNS 查询时间 (dnsTime)：从 DNS 查询开始到 DNS 查询结束的时间。
        tcpTime: metrics.connectEnd - metrics.connectStart,				//TCP 连接时间 (tcpTime)：从 TCP 连接开始到 TCP 连接结束的时间。
        sslTime: metrics.connectEnd - metrics.secureConnectionStart,	//SSL 握手时间 (sslTime)：从 SSL 握手开始到 TCP 连接结束的时间。
        requestTime: metrics.responseStart - metrics.requestStart,		//请求时间 (requestTime)：从请求开始到响应开始的时间。
        responseTime: metrics.responseEnd - metrics.responseStart,		//响应时间 (responseTime)：从响应开始到响应结束的时间。
        domLoadingTime: metrics.domInteractive - metrics.domLoading,	//DOM 加载时间 (domLoadingTime)：从 DOM 开始加载到 DOM 变为可交互的时间。
        domContentLoadedTime: metrics.domContentLoadedEventEnd - metrics.domContentLoadedEventStart,  //DOM 内容加载时间
        domCompleteTime: metrics.domComplete - metrics.domInteractive,	//DOM 完成时间 (domCompleteTime)：从 DOM 变为可交互到 DOM 完成的时间。
        loadEventTime: metrics.loadEventEnd - metrics.loadEventStart,	//加载事件时间 (loadEventTime)：从 load 事件开始到结束的时间。
        totalLoadTime: metrics.loadEventEnd - metrics.navigationStart	//总加载时间 (totalLoadTime)：从导航开始到加载事件结束的时间。
      };

      console.log('各个阶段的时间:', stages);

```

### 5、express和koa的区别

&#x9;**Express**是用回调函数的方式来处理异步，会**出现回调地狱问题**，而**Koa**使用的是**异步函数和Promise方式**来处理异步，会更加简洁；

&#x9;Express的中间件是基于回调函数的，需要调用next()函数来传递请求，而Koa的中间件是基于异步函数的，不需要用next()

&#x9;Express 提供了丰富的内置功能，例如路由、模板引擎、静态文件服务等，Koa 更加轻量级，没有内置功能，需要使用第三方库来实现这些功能

&#x9;Express 的学习曲线相对较低，因为它更接近 Node.js 的原生 API，Koa 的学习曲线相对较高，因为它使用了一些新的概念，例如异步函数和 Promise。

```javascript
import { Plugin } from 'vite';
import { resolve } from 'path';

export default function generateComponentListPlugin() {
  return {
    name: 'generate-component-list',
    apply: 'build',
    configResolved(config) {
      // 获取 src/components 目录的绝对路径
      const componentsDir = resolve(config.root, 'src', 'components');

      // 定义一个函数，用于获取组件名
      function getComponentName(file) {
        return file.replace(/\.vue$/, '').replace(/\/[^\/]*$/, '');
      }

      // 定义一个函数，用于生成 JSON 文件
      function generateJson(components) {
        const json = JSON.stringify({ components });
        return {
          code: `export default ${json}`,
          map: null,
        };
      }

      // 在 build 阶段执行
      config.build.rollupOptions.output.manualChunks = (id) => {
        if (id.startsWith(componentsDir)) {
          // 获取组件名
          const componentName = getComponentName(id);
          // 将组件名添加到数组中
          config.plugins.push({
            name: 'component-list-plugin',
            apply: 'build',
            generateBundle(options, bundle) {
              // 生成 JSON 文件
              bundle['component-list.json'] = generateJson(
                Object.keys(bundle).filter((key) =>
                  key.startsWith(componentsDir)
                ).map(getComponentName)
              );
            },
          });
          // 返回一个唯一的 chunk 名
          return 'components';
        }
      };
    },
  };
}
```

.

.

.

.

.

.

.

.

.

\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_end\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_\_
